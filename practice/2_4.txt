1
00:00:00,000 --> 00:00:04,080
上个视频中 我们讲到了指数加权平均数(字幕来源：网易云课堂)
In the last video, we talked about exponentially weighted averages.

2
00:00:04,080 --> 00:00:07,960
这是几个优化算法中的关键一环
This will turn out to be a key component of several optimization algorithms

3
00:00:07,960 --> 00:00:09,910
而这几个优化算法能帮助你训练神经网络
that you used to train your neural networks.

4
00:00:09,910 --> 00:00:12,330
本视频中 我希望进一步探讨
So, in this video, I want to delve a little bit deeper

5
00:00:12,330 --> 00:00:15,930
算法的本质作用
into intuitions for what this algorithm is really doing.

6
00:00:15,930 --> 00:00:18,000
回忆一下这个计算指数加权平均数
Recall that this is a key equation

7
00:00:18,000 --> 00:00:21,305
的关键方程
for implementing exponentially weighted averages.

8
00:00:21,305 --> 00:00:24,755
beta为0.9的时候 得到的结果是红线
And so, if beta equals 0.9 you got the red line.

9
00:00:24,755 --> 00:00:26,390
如果它更接近于1
If it was much closer to one,

10
00:00:26,390 --> 00:00:29,700
比如0.98 结果就是绿线
if it was 0.98, you get the green line.

11
00:00:29,700 --> 00:00:31,200
如果β小一点
And it it's much smaller,

12
00:00:31,200 --> 00:00:34,470
如果是0.5 结果就是黄线
maybe 0.5, you get the yellow line.

13
00:00:34,470 --> 00:00:35,960
我们进一步地分析
Let's look a bit more than that

14
00:00:35,960 --> 00:00:40,220
来理解如何计算出每日温度的平均值
to understand how this is computing averages of the daily temperature.

15
00:00:40,220 --> 00:00:41,935
同样的公式
So here's that equation again,

16
00:00:41,930 --> 00:00:44,000
使β等于0.9
and let's set beta equals 0.9

17
00:00:44,000 --> 00:00:48,330
写下相应的几个公式
and write out a few equations that this corresponds to.

18
00:00:48,330 --> 00:00:50,100
所以在执行的时候
So whereas, when you're implementing it

19
00:00:50,100 --> 00:00:54,105
所以t从0到1 到2 到3
you have t going from zero to one, to two to three,

20
00:00:54,100 --> 00:00:55,660
t的值在不断增加
increasing values of t.

21
00:00:55,660 --> 00:00:56,760
为了更好地分析
To analyze it,

22
00:00:56,760 --> 00:00:59,640
我写的时候使得t的值不断减小
I've written it with decreasing values of t.

23
00:00:59,640 --> 00:01:00,740
然后继续往下写
And this goes on.

24
00:01:00,740 --> 00:01:03,055
首先看第一个公式
So let's take this first equation here,

25
00:01:03,055 --> 00:01:06,750
v_100是什么
and understand what v_100 really is.

26
00:01:06,750 --> 00:01:09,795
v_100等于
So v_100 is going to be,

27
00:01:09,795 --> 00:01:11,850
我们调换一下这两项
let me reverse these two terms,

28
00:01:11,850 --> 00:01:15,195
0.1乘以100号数据
it's going to be 0.1 times data 100,

29
00:01:15,195 --> 00:01:19,620
加上0.9和前一天数值的乘积
plus 0.9 times whatever the value was on the previous day.

30
00:01:19,620 --> 00:01:21,055
那v_99是什么
Now, but what is v_99?

31
00:01:21,055 --> 00:01:25,075
我们就代入这个公式
Well, we'll just plug it in from this equation.

32
00:01:25,075 --> 00:01:30,390
所以就是0.1乘以99号数据
So this is just going to be 0.1 times data 99,

33
00:01:30,390 --> 00:01:33,215
我又把这两项调换了一下
and again I've reversed these two terms,

34
00:01:33,215 --> 00:01:38,030
再加上0.9和v_98的乘积
plus 0.9 times v_98.

35
00:01:38,030 --> 00:01:39,485
那v_98是什么
But then what is v_98?

36
00:01:39,485 --> 00:01:41,765
你可以用这个公式计算
Well, you just get that from here.

37
00:01:41,765 --> 00:01:44,220
把公式代进去
So you can just plug in here,

38
00:01:44,220 --> 00:01:47,875
0.1乘以98号数据
0.1 times data 98,

39
00:01:47,875 --> 00:01:52,560
加上0.9乘以v_97 以此类推
plus 0.9 times v_97, and so on.

40
00:01:52,560 --> 00:01:54,405
如果你把这些括号都展开
And if you multiply all of these terms out,

41
00:01:54,405 --> 00:02:00,060
v_100就是0.1乘以100号数据加上
you can show that v_100 is 0.1 times data 100 plus.

42
00:02:00,060 --> 00:02:02,851
我们来看99号数据的系数
Now, let's look at coefficient on data 99,

43
00:02:02,851 --> 00:02:09,030
也就是0.1乘以0.9乘以99号数据
it's going to be 0.1 times 0.9, times data 99.

44
00:02:09,030 --> 00:02:12,160
再看看98号数据的系数
Now, let's look at the coefficient on data 98,

45
00:02:12,160 --> 00:02:16,880
0.1乘以0.9乘以0.9
there's a 0.1 here times 0.9, times 0.9.

46
00:02:16,880 --> 00:02:18,565
若继续展开多项式
So if we expand out the Algebra,

47
00:02:18,565 --> 00:02:26,295
也就是0.1乘以0.9的平方乘以98号数据
this become 0.1 times 0.9 squared, times data 98.

48
00:02:26,295 --> 00:02:28,260
如果继续展开
And, if you keep expanding this out,

49
00:02:28,260 --> 00:02:33,980
就会出现0.1乘以0.9的三次方乘以97号数据
you find that this becomes 0.1 times 0.9 cubed, data 97.

50
00:02:33,980 --> 00:02:39,216
加上0.1乘以0.9的四次方乘以96号数据
plus 0.1 times 0.9 to the fourth,times data 96,

51
00:02:39,216 --> 00:02:41,800
一直下去
plus dot dot dot.

52
00:02:41,800 --> 00:02:47,010
所以这是一个加和并平均
So this is really a way to sum and that's a way to average of data 100,

53
00:02:47,010 --> 00:02:48,940
100号数据 也就是当日温度的方法
which is the current days temperature

54
00:02:48,940 --> 00:02:51,280
我们分析v_100的组成
and we're looking for a perspective of v_100

55
00:02:51,280 --> 00:02:53,280
也就是在一年第100天计算的数据
which you calculate on the 100th day of the year.

56
00:02:53,730 --> 00:02:56,870
但是这个是总和 包括100号数据
But those are sum of your data 100,

57
00:02:56,870 --> 00:03:02,175
99号数据 98号数据 97号数据等等
data 99, data 98, data 97, data 96, and so on.

58
00:03:02,175 --> 00:03:05,250
画图的一个办法是
So one way to draw this in pictures would be if,

59
00:03:05,250 --> 00:03:08,880
假设我们有一些日期的温度
let's say we have some number of days of temperature.

60
00:03:08,880 --> 00:03:11,660
所以这是数据 这是t
So this is data and this is t.

61
00:03:11,660 --> 00:03:14,610
所以100号数据有个数值
So data 100 will be some value,

62
00:03:14,610 --> 00:03:17,095
99号数据有个数值
then data 99 will be some value,

63
00:03:17,095 --> 00:03:19,360
98号数据等等
data 98, so these are,

64
00:03:19,360 --> 00:03:23,070
t为100 99 98等等
so this is t equals 100, 99, 98, and so on,

65
00:03:23,070 --> 00:03:26,360
这就是数日的温度数值
Right? It's some number of days of temperature.

66
00:03:26,360 --> 00:03:31,015
然后我们构建一个指数衰减函数
And what we have is then an exponentially decaying function.

67
00:03:31,010 --> 00:03:33,814
从0.1开始
So starting from 0.1,

68
00:03:33,810 --> 00:03:38,508
到0.9乘以0.1
to 0.9 times 0.1,

69
00:03:38,508 --> 00:03:44,555
到0.9的平方乘以0.1 以此类推
to 0.9 squared times 0.1, to and so on.

70
00:03:44,555 --> 00:03:47,150
所以就有了这个指数衰减函数
So you have this exponentially decaying function.

71
00:03:47,150 --> 00:03:50,600
计算v_100是通过
And the way you compute v_100,

72
00:03:50,600 --> 00:03:55,760
把两个函数对应的元素相乘 然后求和
is you take the element wise product between these two functions and sum it up.

73
00:03:55,760 --> 00:03:59,165
用这个数值 100号数据乘以0.1
So you take this value, data 100 times 0.1,

74
00:03:59,165 --> 00:04:05,770
99号数据值乘以0.1乘以0.9
times, this value of data 99 times 0.1 times 0.9,

75
00:04:05,770 --> 00:04:07,995
这是第二项 以此类推
that's the second term and so on.

76
00:04:07,995 --> 00:04:10,170
所以选取的是每日温度
So it's really taking the daily temperature,

77
00:04:10,170 --> 00:04:14,610
将其与指数衰减函数相乘 然后求和
multiply with this exponentially decaying function, and then summing it up.

78
00:04:14,610 --> 00:04:17,390
就得到了v_100
And this becomes your v_100.

79
00:04:17,390 --> 00:04:19,165
结果是
It turns out that,

80
00:04:19,165 --> 00:04:21,090
稍后我们详细讲解
up to details that are for later.

81
00:04:21,090 --> 00:04:22,655
不过所有的这些系数
But all of these coefficients,

82
00:04:22,655 --> 00:04:27,335
相加起来为1或者逼近1
add up to one or add up to very close to one,

83
00:04:27,335 --> 00:04:31,670
我们称之为偏差修正 下个视频会涉及
up to a detail called bias correction which we'll talk about in the next video.

84
00:04:31,670 --> 00:04:35,225
因为有偏差修正 这才是指数加权平均数
But because of that, this really is an exponentially weighted average.

85
00:04:35,225 --> 00:04:37,595
最后也许你会问
And finally, you might wonder,

86
00:04:37,595 --> 00:04:41,210
到底需要平均多少天的温度
how many days temperature is this averaging over.

87
00:04:41,210 --> 00:04:46,400
实际上 0.9的10次方
Well, it turns out that 0.9 to the power of 10,

88
00:04:46,400 --> 00:04:52,085
大约为0.35 这大约是1/e
is about 0.35 and this turns out to be about one over e,

89
00:04:52,085 --> 00:04:54,410
e是自然算法的基础之一
one of the base of natural algorithms.

90
00:04:54,410 --> 00:04:59,030
大体上说 如果有1-ε
And, more generally, if you have one minus epsilon,

91
00:04:59,030 --> 00:05:00,200
在这个例子中
so in this example,

92
00:05:00,200 --> 00:05:03,299
ε是0.1 所以这个是0.9
epsilon would be 0.1, so this is 0.9,

93
00:05:03,299 --> 00:05:08,720
(1-ε)的(1/ε)次方约等于1/e
then one minus epsilon to the one over epsilon, this is about one over e,

94
00:05:08,720 --> 00:05:12,065
大约是0.34 0.35
this about 0.34, 0.35.

95
00:05:12,065 --> 00:05:14,735
换句话说
And so, in other words,

96
00:05:14,735 --> 00:05:19,610
10天后 曲线的高度
it takes about 10 days for the height of this to

97
00:05:19,610 --> 00:05:24,680
下降到三分之一 相当于在峰值的1/e
decay to around 1/3 already one over e of the peak.

98
00:05:24,680 --> 00:05:31,325
又因此当β=0.9的时候 我们说
So it's because of this, that when beta equals 0.9, we say that,

99
00:05:31,320 --> 00:05:37,320
仿佛你在计算一个指数加权平均数
this is as if you're computing an exponentially weighted average

100
00:05:37,320 --> 00:05:40,355
只关注了过去10天的温度
that focuses on just the last 10 days temperature.

101
00:05:40,350 --> 00:05:42,437
因为10天后
Because it's after 10 days

102
00:05:42,437 --> 00:05:48,380
权重下降到不到当日权重的三分之一
that the weight decays to less than about a third of the weight of the current day.

103
00:05:48,380 --> 00:05:53,300
相反 如果β=0.98
Whereas, in contrast, if beta was equal to 0.98,

104
00:05:53,300 --> 00:05:59,320
那么0.98需要多少次方才能达到这么小的数值？
then, well, what do you need 0.98 to the power of in order for this to really small?

105
00:05:59,320 --> 00:06:05,480
0.98的50次方大约等于1/e
Turns out that 0.98 to the power of 50 will be approximately equal to one over e.

106
00:06:05,480 --> 00:06:09,380
所以前50天这个数值比1/e大
So the way to be pretty big will be bigger than one over e for the first 50 days,

107
00:06:09,380 --> 00:06:11,840
数值会快速衰减
and then they'll decay quite rapidly over that.

108
00:06:11,840 --> 00:06:14,780
所以本质上这是一个下降幅度很大的函数
So intuitively, this is the hard and fast thing,

109
00:06:14,780 --> 00:06:18,860
你可以看作平均了50天的温度
you can think of this as averaging over about 50 days temperature.

110
00:06:18,860 --> 00:06:20,335
因为在例子中
Because, in this example,

111
00:06:20,335 --> 00:06:22,290
要代入等式的左边
to use the notation here on the left,

112
00:06:22,290 --> 00:06:25,530
ε=0.02
it's as if epsilon is equal to 0.02,

113
00:06:25,530 --> 00:06:27,750
所以1/ε为50
so one over epsilon is 50.

114
00:06:27,750 --> 00:06:30,080
我们由此得到公式
And this, by the way, is how we got the formula,

115
00:06:30,080 --> 00:06:35,150
我们平均了大约1/(1-β)天的温度
that we're averaging over one over one minus beta or so days.

116
00:06:35,150 --> 00:06:39,915
这里ε替代了1-β
Right here, epsilon replace a row of 1 minus beta.

117
00:06:39,910 --> 00:06:41,832
也就是说根据一些常数
It tells you, up to some constant

118
00:06:41,832 --> 00:06:45,148
你能大概知道能够平均多少日的温度
roughly how many days temperature you should think of this as averaging over.

119
00:06:45,148 --> 00:06:48,175
不过这只是思考的大致方向
But this is just a rule of thumb for how to think about it,

120
00:06:48,175 --> 00:06:51,290
并不是正式的数学证明
and it isn't a formal mathematical statement.

121
00:06:51,290 --> 00:06:54,290
最后讲讲如何在实际中执行
Finally, let's talk about how you actually implement this.

122
00:06:54,290 --> 00:06:57,760
还记得吗 我们一开始将v_0设置为0
Recall that we start over V0 initialized as zero,

123
00:06:57,760 --> 00:06:59,570
然后计算第一天v_1
then compute v one on the first day,

124
00:06:59,570 --> 00:07:01,605
然后v_2 以此类推
v_2, and so on.

125
00:07:01,600 --> 00:07:03,265
现在 解释一下算法
Now, to explain the algorithm,

126
00:07:03,265 --> 00:07:09,480
可以v_0 v_1 v_2等等写成明确的变量
it was useful to write down v_0, v_1, v_2, and so on as distinct variables.

127
00:07:09,480 --> 00:07:11,835
不过在实际中执行的话
But if you're implementing this in practice,

128
00:07:11,835 --> 00:07:15,774
你要做的是 一开始将v初始化为0
this is what you do: you initialize V to be called to zero,

129
00:07:15,774 --> 00:07:17,555
然后在第一天
and then on day one,

130
00:07:17,555 --> 00:07:25,405
使v等于β乘以v加上(1-β)乘以1号数据
you would set v equals beta,times v, plus one minus beta, times data one.

131
00:07:25,405 --> 00:07:27,780
然后第二天 更新v值
And then on the next day, you add update v,

132
00:07:27,780 --> 00:07:35,985
βV+(1-β)乘以2号数据 以此类推
to be called to beta V,
plus 1 minus beta,data 2, and so on.

133
00:07:35,980 --> 00:07:40,413
有些人会把v加下标
And some of it uses notation V subscript data

134
00:07:40,413 --> 00:07:47,115
来表示v是用来计算数据的指数加权平均数
to denote that V is computing this exponentially weighted average of the parameter data.

135
00:07:47,115 --> 00:07:49,690
再说一次 但是换个说法
So just to say this again but for a new format,

136
00:07:49,690 --> 00:07:52,095
v = 0
you set v data equals zero,

137
00:07:52,095 --> 00:07:55,715
然后每一天
and then, repeatedly, have one each day,

138
00:07:55,710 --> 00:08:00,608
拿到第t天的数据
you would get next data t,

139
00:08:00,600 --> 00:08:04,671
把v更新为
and then set to v, data gets updated as

140
00:08:04,671 --> 00:08:07,210
β乘上旧的v
beta, times the old value of v data,

141
00:08:07,210 --> 00:08:12,045
加上(1-β)乘以第t天的数据
plus one minus beta, times the current value of the data.

142
00:08:12,045 --> 00:08:15,440
指数加权平均数公式的好处之一在于
So one of the advantages of this exponentially weighted average formula,

143
00:08:15,440 --> 00:08:17,140
它只占用极少内存
s that it takes very little memory.

144
00:08:17,140 --> 00:08:21,175
电脑内存中只占一行数字而已
You just need to keep just one row number in computer memory,

145
00:08:21,170 --> 00:08:24,840
然后把最新数据代入公式
and you keep on overwriting it with this formula

146
00:08:24,840 --> 00:08:26,965
不断覆盖就可以了
based on the latest values that you got.

147
00:08:26,965 --> 00:08:29,590
正因为这个原因 其效率
And it's really this reason, the efficiency,

148
00:08:29,590 --> 00:08:33,340
它基本上只占一行代码
it just takes up one line of code basically and just

149
00:08:33,340 --> 00:08:38,320
计算指数加权平均数也只占单行数字的储存和内存
storage and memory for a single row number to compute this exponentially weighted average.

150
00:08:38,320 --> 00:08:40,195
当然它并不是最好的
It's really not the best way,

151
00:08:40,195 --> 00:08:42,805
也不是最精准的计算平均数的方法
not the most accurate way to compute an average.

152
00:08:42,805 --> 00:08:44,920
如果你要计算移动窗
If you were to compute a moving window,

153
00:08:44,920 --> 00:08:49,400
你直接算出过去10天的总和 过去50天的总和
where you explicitly sum over the last 10 days,the last 50 days temperature

154
00:08:49,400 --> 00:08:51,550
除以10和50就好
just divide by 10 or divide by 50,

155
00:08:51,550 --> 00:08:53,320
如此往往会得到更好的估测
that usually gives you a better estimate.

156
00:08:53,320 --> 00:08:55,265
但缺点是
But the disadvantage of that,

157
00:08:55,260 --> 00:08:57,517
如果保存所有最近的温度数据
of explicitly keeping all the temperatures around

158
00:08:57,517 --> 00:08:58,991
和过去10天的总和
and sum of the last 10 days,

159
00:08:58,991 --> 00:09:00,190
必须占更多的内存
 is it requires more memory,

160
00:09:00,190 --> 00:09:02,241
执行更加复杂
and it's just more complicated to implement

161
00:09:02,241 --> 00:09:03,990
计算成本也更加高昂
and is computationally more expensive.

162
00:09:03,990 --> 00:09:07,885
所以在接下来的视频中
So for things, we'll see some examples on the next few videos,

163
00:09:07,885 --> 00:09:12,130
我们会计算多个变量的平均值
where you need to compute averages of a lot of variables.

164
00:09:12,130 --> 00:09:14,474
从计算和内存效率来说
This is a very efficient way to do so

165
00:09:14,470 --> 00:09:17,274
这是一个有效的方法
both from computation and memory efficiency point of view

166
00:09:17,274 --> 00:09:19,840
所以在机器学习中会经常使用
which is why it's used in a lot of machine learning.

167
00:09:19,840 --> 00:09:22,379
更不用说只要一行代码
Not to mention that there's just one line of code

168
00:09:22,379 --> 00:09:24,280
这也是一个优势
which is, maybe, another advantage.

169
00:09:24,280 --> 00:09:28,570
现在你学会了计算指数加权平均数
So, now, you know how to implement exponentially weighted averages.

170
00:09:28,570 --> 00:09:31,330
你还需要知道一个专业概念
There's one more technical detail that's worth for you knowing about

171
00:09:31,330 --> 00:09:32,965
叫作偏差修正
called bias correction.

172
00:09:32,960 --> 00:09:34,463
下一个视频我们会讲到它
Let's see that in the next video,

173
00:09:34,460 --> 00:09:39,242
接着你就可以用它构建更好的优化算法
and then after that, you will use this to build a better optimization algorithm

174
00:09:39,242 --> 00:09:41,450
而不是简单直接的梯度下降法
than the straight forward gradient descent.

